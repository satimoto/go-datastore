// Code generated by sqlc. DO NOT EDIT.
// source: geo_location.sql

package db

import (
	"context"
	"database/sql"
)

const createGeoLocation = `-- name: CreateGeoLocation :one
INSERT INTO geo_locations (
     latitude, 
     latitude_float, 
     longitude, 
     longitude_float, 
     name
  ) VALUES ($1, $2, $3, $4, $5)
  RETURNING id, latitude, latitude_float, longitude, longitude_float, name
`

type CreateGeoLocationParams struct {
	Latitude       string         `db:"latitude" json:"latitude"`
	LatitudeFloat  float64        `db:"latitude_float" json:"latitudeFloat"`
	Longitude      string         `db:"longitude" json:"longitude"`
	LongitudeFloat float64        `db:"longitude_float" json:"longitudeFloat"`
	Name           sql.NullString `db:"name" json:"name"`
}

func (q *Queries) CreateGeoLocation(ctx context.Context, arg CreateGeoLocationParams) (GeoLocation, error) {
	row := q.db.QueryRowContext(ctx, createGeoLocation,
		arg.Latitude,
		arg.LatitudeFloat,
		arg.Longitude,
		arg.LongitudeFloat,
		arg.Name,
	)
	var i GeoLocation
	err := row.Scan(
		&i.ID,
		&i.Latitude,
		&i.LatitudeFloat,
		&i.Longitude,
		&i.LongitudeFloat,
		&i.Name,
	)
	return i, err
}

const deleteGeoLocation = `-- name: DeleteGeoLocation :exec
DELETE FROM geo_locations
  WHERE id = $1
`

func (q *Queries) DeleteGeoLocation(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteGeoLocation, id)
	return err
}

const getGeoLocation = `-- name: GetGeoLocation :one
SELECT id, latitude, latitude_float, longitude, longitude_float, name FROM geo_locations
  WHERE id = $1
`

func (q *Queries) GetGeoLocation(ctx context.Context, id int64) (GeoLocation, error) {
	row := q.db.QueryRowContext(ctx, getGeoLocation, id)
	var i GeoLocation
	err := row.Scan(
		&i.ID,
		&i.Latitude,
		&i.LatitudeFloat,
		&i.Longitude,
		&i.LongitudeFloat,
		&i.Name,
	)
	return i, err
}

const listGeoLocations = `-- name: ListGeoLocations :many
SELECT id, latitude, latitude_float, longitude, longitude_float, name FROM geo_locations
  ORDER BY name
`

func (q *Queries) ListGeoLocations(ctx context.Context) ([]GeoLocation, error) {
	rows, err := q.db.QueryContext(ctx, listGeoLocations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GeoLocation
	for rows.Next() {
		var i GeoLocation
		if err := rows.Scan(
			&i.ID,
			&i.Latitude,
			&i.LatitudeFloat,
			&i.Longitude,
			&i.LongitudeFloat,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateGeoLocation = `-- name: UpdateGeoLocation :one
UPDATE geo_locations SET (
    latitude, 
    latitude_float, 
    longitude, 
    longitude_float, 
    name
  ) = ($2, $3, $4, $5, $6)
  WHERE id = $1
  RETURNING id, latitude, latitude_float, longitude, longitude_float, name
`

type UpdateGeoLocationParams struct {
	ID             int64          `db:"id" json:"id"`
	Latitude       string         `db:"latitude" json:"latitude"`
	LatitudeFloat  float64        `db:"latitude_float" json:"latitudeFloat"`
	Longitude      string         `db:"longitude" json:"longitude"`
	LongitudeFloat float64        `db:"longitude_float" json:"longitudeFloat"`
	Name           sql.NullString `db:"name" json:"name"`
}

func (q *Queries) UpdateGeoLocation(ctx context.Context, arg UpdateGeoLocationParams) (GeoLocation, error) {
	row := q.db.QueryRowContext(ctx, updateGeoLocation,
		arg.ID,
		arg.Latitude,
		arg.LatitudeFloat,
		arg.Longitude,
		arg.LongitudeFloat,
		arg.Name,
	)
	var i GeoLocation
	err := row.Scan(
		&i.ID,
		&i.Latitude,
		&i.LatitudeFloat,
		&i.Longitude,
		&i.LongitudeFloat,
		&i.Name,
	)
	return i, err
}
